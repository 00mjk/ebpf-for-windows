/*
 *  Copyright (c) Microsoft Corporation
 *  SPDX-License-Identifier: MIT
*/

/*++

Abstract:
WDF based driver that does the following:
1. Registers as a WFP L2 Callout
2. Opens a IOCTL surface

Environment:

    Kernel mode

--*/

#include <ntddk.h>
#include <wdf.h>


#pragma warning(push)
#pragma warning(disable:4201)       // unnamed struct/union

#include <fwpsk.h>

#pragma warning(pop)

#include <fwpmk.h>
#include <netiodef.h>
#include "ebpf_l2_hook.h"
#include "types.h"
#include "protocol.h"
#include "ebpf_core.h"

// Driver global variables

DEVICE_OBJECT* gWdmDevice;
BOOLEAN gDriverUnloading = FALSE;
DRIVER_INITIALIZE DriverEntry;
EVT_WDF_DRIVER_UNLOAD EvtDriverUnload;

// Typedefs 
typedef enum
{
    ebpfPoolTag = 'fpbe'
} EBPF_POOL_TAG;

typedef VOID(WINAPI* FUNCTION_TYPE) (VOID);
typedef DWORD(WINAPI* FUNCTION_TYPE1) (DWORD);
typedef DWORD(WINAPI* FUNCTION_TYPE2) (PVOID, PVOID);

//
// Constants
//
PCWSTR EbpfDeviceName = L"\\Device\\EbpfIoDevice";
PCWSTR EbpfSymbolicDeviceName = L"\\GLOBAL??\\EbpfIoDevice";

#ifndef CTL_CODE
#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)
#endif
// Device type 
#define EBPF_IOCTL_TYPE FILE_DEVICE_NETWORK

// Function codes from 0x800 to 0xFFF are for customer use.
#define IOCTL_EBPFCTL_METHOD_BUFFERED \
    CTL_CODE( EBPF_IOCTL_TYPE, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS  )

//
// Pre-Declarations
//
VOID
EbpfCoreEvtIoDeviceControl(
    _In_ WDFQUEUE      queue,
    _In_ WDFREQUEST    request,
    _In_ size_t        outputBufferLength,
    _In_ size_t        inputBufferLength,
    _In_ ULONG         ioControlCode
    );

_Function_class_(EVT_WDF_DRIVER_UNLOAD)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
void
EvtDriverUnload(
   _In_ WDFDRIVER driverObject
   )
{
   UNREFERENCED_PARAMETER(driverObject);

   gDriverUnloading = TRUE; 

   EbpfHookUnregisterCallouts();

   EbpfCoreTerminate();
}

//
// Create a basic WDF driver, set up the device object
// for a callout driver and setup the ioctl surface
//
NTSTATUS
EbpfCoreInitDriverObjects(
   _Inout_ DRIVER_OBJECT* driverObject,
   _In_ const UNICODE_STRING* registryPath,
   _Out_ WDFDRIVER* pDriver,
   _Out_ WDFDEVICE* pDevice
   )
{
    NTSTATUS status;
    WDF_DRIVER_CONFIG config;
    PWDFDEVICE_INIT pInit = NULL;
    WDF_IO_QUEUE_CONFIG ioQueueConfig;
    UNICODE_STRING ebpfDeviceName;
    UNICODE_STRING ebpfSymDeviceName;
    BOOLEAN deviceCreated = FALSE;

    WDF_DRIVER_CONFIG_INIT(
        &config,
        WDF_NO_EVENT_CALLBACK
    );

    config.DriverInitFlags |= WdfDriverInitNonPnpDriver;
    config.EvtDriverUnload = EvtDriverUnload;

    status = WdfDriverCreate(
        driverObject,
        registryPath,
        WDF_NO_OBJECT_ATTRIBUTES,
        &config,
        pDriver
    );

    if (!NT_SUCCESS(status))
    {
        goto Exit;
    }

    pInit = WdfControlDeviceInitAllocate(
        *pDriver,
        &SDDL_DEVOBJ_SYS_ALL_ADM_ALL // only kernel/system and admins
    );
    if (!pInit)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }

    WdfDeviceInitSetDeviceType(
        pInit,
        FILE_DEVICE_NETWORK
    );

    WdfDeviceInitSetCharacteristics(
        pInit,
        FILE_DEVICE_SECURE_OPEN,
        FALSE
    );

    WdfDeviceInitSetCharacteristics(
        pInit,
        FILE_AUTOGENERATED_DEVICE_NAME,
        TRUE
    );

    RtlInitUnicodeString(&ebpfDeviceName, EbpfDeviceName);
    WdfDeviceInitAssignName(
        pInit,
        &ebpfDeviceName);

    status = WdfDeviceCreate(
        &pInit,
        WDF_NO_OBJECT_ATTRIBUTES,
        pDevice
    );

    if (!NT_SUCCESS(status))
    {
        // do not free if any other call 
        // after WdfDeviceCreate fails.
        WdfDeviceInitFree(pInit);
        pInit = NULL;
        goto Exit;
    }

    deviceCreated = TRUE;

    // create symbolic link for control object for um
    RtlInitUnicodeString(&ebpfSymDeviceName, EbpfSymbolicDeviceName);
    status = WdfDeviceCreateSymbolicLink(
        *pDevice,
        &ebpfSymDeviceName);

    if (!NT_SUCCESS(status))
    {
        goto Exit;
    }

    // parallel default queue
    WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&ioQueueConfig,
        WdfIoQueueDispatchParallel);

    ioQueueConfig.EvtIoDeviceControl = EbpfCoreEvtIoDeviceControl;

    status = WdfIoQueueCreate(
        *pDevice,
        &ioQueueConfig,
        WDF_NO_OBJECT_ATTRIBUTES,
        WDF_NO_HANDLE // pointer to default queue
    );
    if (!NT_SUCCESS(status))
    {
        goto Exit;
    }
    status = EbpfCoreInitialize();
    if (!NT_SUCCESS(status))
    {
        goto Exit;
    }

    WdfControlFinishInitializing(*pDevice);

Exit:
    if (!NT_SUCCESS(status))
    {
        if (deviceCreated && pDevice != NULL)
        {
            //
            // Release the reference on the newly created object, since
            // we couldn't initialize it.
            //
            WdfObjectDelete(*pDevice);
        }
    }
    return status;
}

// Dummy drop function
int DropPacket(unsigned int protocol)
{

    if (protocol == IPPROTO_UDP)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

const struct {
    NTSTATUS(*protocol_handler)(_In_ void* inputBuffer, void* outputBuffer);
    SIZE_T minimum_request_size;
    BOOL has_output;
} EbpfProtocolHandlers[] = {
    { NULL, sizeof(struct EbpfOpEvidenceRequest) }, //evidence 
    { EbpfCoreProtocolResolveHelper, sizeof(struct EbpfOpResolveHelperRequest), TRUE },
    { EbpfCoreProtocolResolveMap, sizeof(struct EbpfOpResolveMapRequest), TRUE },
    { EbpfCoreProtocolLoadCode, sizeof(struct EbpfOpLoadRequest), TRUE },
    { EbpfCoreProtocolUnloadCode, sizeof(struct EbpfOpUnloadRequest), FALSE },
    { EbpfCoreProtocolAttachCode, sizeof(struct EbpfOpAttachDetachRequest), FALSE },
    { EbpfCoreProtocolDetachCode, sizeof(struct EbpfOpAttachDetachRequest), FALSE },
    { EbpfCoreProtocolCreateMap, sizeof(struct EbpfOpCreateMapRequest), TRUE },
    { EbpfCoreProtocolMapLookupElement, sizeof(struct EbpfOpMapLookupElementRequest), TRUE },
    { EbpfCoreProtocolMapUpdateElement, sizeof(struct EpfOpMapUpdateElementRequest), FALSE },
    { EbpfCoreProtocolMapDeleteElement, sizeof(struct EbpfOpMapDeleteElementRequest), FALSE }
};

VOID
EbpfCoreEvtIoDeviceControl(
    _In_ WDFQUEUE      queue,
    _In_ WDFREQUEST    request,
    _In_ size_t        outputBufferLength,
    _In_ size_t        inputBufferLength,
    _In_ ULONG         ioControlCode
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    WDFDEVICE device;
    void* inputBuffer = NULL;
    void* outputBuffer = NULL;
    size_t actualInputLength;
    size_t actualOutputLength;
    struct EbpfOpHeader* inputRequest = NULL;
    struct EbpfOpHeader* outputRequest = NULL;

    UNREFERENCED_PARAMETER(outputBufferLength);
    UNREFERENCED_PARAMETER(inputBufferLength);

    device = WdfIoQueueGetDevice(queue);

    switch (ioControlCode)
    {
    case IOCTL_EBPFCTL_METHOD_BUFFERED:
        // Verify that length of the input buffer supplied to the request object
        // is not zero
        if (inputBufferLength != 0)
        {
            // Retrieve the input buffer associated with the request object
            status = WdfRequestRetrieveInputBuffer(
                request,                   // Request object
                inputBufferLength,         // Length of input buffer
                &inputBuffer,              // Pointer to buffer
                &actualInputLength         // Length of buffer
            );

            if (!NT_SUCCESS(status))
            {
                KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "EbpfCore: Input buffer failure %d\n", status));
                goto Done;
            }

            if (inputBuffer == NULL)
            {
                status = STATUS_INVALID_PARAMETER;
                goto Done;
            }

            if (inputBuffer != NULL)
            {

                status = EbpfHookRegisterCallouts(gWdmDevice);
                // non fatal for now while testing               

                inputRequest = inputBuffer;
                if (actualInputLength < sizeof(struct EbpfOpHeader))
                {
                    status = STATUS_INVALID_PARAMETER;
                    goto Done;
                }

                if (inputRequest->id >= sizeof(EbpfProtocolHandlers) / sizeof(EbpfProtocolHandlers[0]))
                {
                    status = STATUS_INVALID_PARAMETER;
                    goto Done;
                }

                if (inputRequest->length < EbpfProtocolHandlers[inputRequest->id].minimum_request_size)
                {
                    status = STATUS_INVALID_PARAMETER;
                    goto Done;
                }

                if (!EbpfProtocolHandlers[inputRequest->id].protocol_handler)
                {
                    status = STATUS_INVALID_PARAMETER;
                    goto Done;
                }

                if (EbpfProtocolHandlers[inputRequest->id].has_output)
                {
                    // Retrieve output buffer associated with the request object
                    status = WdfRequestRetrieveOutputBuffer(
                        request,
                        outputBufferLength,
                        &outputBuffer,
                        &actualOutputLength
                    );
                    if (!NT_SUCCESS(status))
                    {
                        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "EbpfCore: Output buffer failure %d\n", status));
                        goto Done;
                    }
                    if (outputBuffer == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                        goto Done;
                    }

                    outputRequest->id = inputRequest->id;
                    outputRequest->length = (uint16_t)actualOutputLength;
                }

                status = EbpfProtocolHandlers[inputRequest->id].protocol_handler(inputBuffer, outputBuffer);
                goto Done;
            }
        }
        else
        {
            status = NDIS_STATUS_INVALID_PARAMETER;
            goto Done;
        }
        break;
    default:
        break;
    }

Done:
    WdfRequestCompleteWithInformation(request, status, outputBufferLength);
    return;
}

NTSTATUS
DriverEntry(
   _In_ DRIVER_OBJECT* driverObject,
   _In_ UNICODE_STRING* registryPath
   )
{
   NTSTATUS status;
   WDFDRIVER driver;
   WDFDEVICE device;

   // Request NX Non-Paged Pool when available
   ExInitializeDriverRuntime(DrvRtPoolNxOptIn);
   
   KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "EbpfCore: DriverEntry\n"));

   status = EbpfCoreInitDriverObjects(
               driverObject,
               registryPath,
               &driver,
               &device
               );

   if (!NT_SUCCESS(status))
   {
      goto Exit;
   }

   gWdmDevice = WdfDeviceWdmGetDeviceObject(device);
   
   EbpfHookRegisterCallouts(gWdmDevice);
   // ignore status. at boot, registration can fail.
   // we will try to re-register during prog load.

Exit:
   
   if (!NT_SUCCESS(status))
   {
        EbpfHookUnregisterCallouts();
   }

   return status;
}

