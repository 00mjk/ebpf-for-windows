/*++

Copyright (c) Microsoft Corporation. All rights reserved

Abstract:
WDF based driver that does the following:
1. Registers as a WFP L2 Callout
2. Opens a IOCTL surface

Environment:

    Kernel mode

--*/

#include <ntddk.h>
#include <wdf.h>

#pragma warning(push)
#pragma warning(disable:4201)       // unnamed struct/union

#include <fwpsk.h>

#pragma warning(pop)

#include <fwpmk.h>

#include "ebpf_l2_hook.h"


// Driver global variables

DEVICE_OBJECT* gWdmDevice;
BOOLEAN gDriverUnloading = FALSE;
DRIVER_INITIALIZE DriverEntry;
EVT_WDF_DRIVER_UNLOAD EvtDriverUnload;
DWORD gError = 0;
DWORD gSuccess = 0;

// Typedefs 
typedef enum
{
    ebpfPoolTag = 'fpbe'
} EBPF_POOL_TAG;

typedef VOID(WINAPI* FUNCTION_TYPE) (VOID);
typedef DWORD(WINAPI* FUNCTION_TYPE1) (DWORD);
typedef DWORD(WINAPI* FUNCTION_TYPE2) (PVOID, PVOID);


//
// Constants
//
PCWSTR EbpfDeviceName = L"\\Device\\EbpfIoDevice";
PCWSTR EbpfSymbolicDeviceName = L"\\GLOBAL??\\EbpfIoDevice";

#ifndef CTL_CODE
#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)
#endif
// Device type 
#define EBPF_IOCTL_TYPE FILE_DEVICE_NETWORK

// Function codes from 0x800 to 0xFFF are for customer use.
#define IOCTL_EBPFCTL_METHOD_BUFFERED \
    CTL_CODE( EBPF_IOCTL_TYPE, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS  )

//
// Pre-Declarations
//
VOID
EbpfCoreEvtIoDeviceControl(
    _In_ WDFQUEUE      queue,
    _In_ WDFREQUEST    request,
    _In_ size_t        outputBufferLength,
    _In_ size_t        inputBufferLength,
    _In_ ULONG         ioControlCode
    );

_Function_class_(EVT_WDF_DRIVER_UNLOAD)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
void
EvtDriverUnload(
   _In_ WDFDRIVER driverObject
   )
{
   UNREFERENCED_PARAMETER(driverObject);

   gDriverUnloading = TRUE; 

   EbpfHookUnregisterCallouts();
}

//
// Create a basic WDF driver, set up the device object
// for a callout driver and setup the ioctl surface
//
NTSTATUS
EbpfCoreInitDriverObjects(
   _Inout_ DRIVER_OBJECT* driverObject,
   _In_ const UNICODE_STRING* registryPath,
   _Out_ WDFDRIVER* pDriver,
   _Out_ WDFDEVICE* pDevice
   )
{
   NTSTATUS status;
   WDF_DRIVER_CONFIG config;
   PWDFDEVICE_INIT pInit = NULL;
   WDF_IO_QUEUE_CONFIG ioQueueConfig;   
   UNICODE_STRING ebpfDeviceName; 
   UNICODE_STRING ebpfSymDeviceName;
   BOOLEAN deviceCreated = FALSE;

   WDF_DRIVER_CONFIG_INIT(
      &config,
      WDF_NO_EVENT_CALLBACK
      );

   config.DriverInitFlags |= WdfDriverInitNonPnpDriver;
   config.EvtDriverUnload = EvtDriverUnload;

   status = WdfDriverCreate(
               driverObject,
               registryPath,
               WDF_NO_OBJECT_ATTRIBUTES,
               &config,
               pDriver
               );

   if (!NT_SUCCESS(status))
   {
      goto Exit;
   }

   DbgBreakPoint();
   pInit = WdfControlDeviceInitAllocate(
               *pDriver,               
               &SDDL_DEVOBJ_SYS_ALL_ADM_ALL // only kernel/system and admins
               );
   if (!pInit)
   {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto Exit;
   }

   WdfDeviceInitSetDeviceType(
      pInit,
      FILE_DEVICE_NETWORK
      );

   WdfDeviceInitSetCharacteristics(
      pInit,
      FILE_DEVICE_SECURE_OPEN,
      FALSE
      );

   WdfDeviceInitSetCharacteristics(
      pInit,
      FILE_AUTOGENERATED_DEVICE_NAME,
      TRUE
      );

   RtlInitUnicodeString(&ebpfDeviceName, EbpfDeviceName);
   WdfDeviceInitAssignName(
      pInit,
      &ebpfDeviceName);

   status = WdfDeviceCreate(
               &pInit,
               WDF_NO_OBJECT_ATTRIBUTES,
               pDevice
               );

   if (!NT_SUCCESS(status))
   {
      // do not free if any other call 
      // after WdfDeviceCreate fails.
      WdfDeviceInitFree(pInit);
      pInit = NULL;
      goto Exit;
   }

   deviceCreated = TRUE;

   // create symbolic link for control object for um
   RtlInitUnicodeString(&ebpfSymDeviceName, EbpfSymbolicDeviceName);
   status = WdfDeviceCreateSymbolicLink(
               *pDevice,
               &ebpfSymDeviceName);

   if (!NT_SUCCESS(status))
   {
      goto Exit;
   }

   // parallel default queue
   WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&ioQueueConfig,
      WdfIoQueueDispatchParallel);

   ioQueueConfig.EvtIoDeviceControl = EbpfCoreEvtIoDeviceControl;

   status = WdfIoQueueCreate(
               *pDevice,
               &ioQueueConfig,
               WDF_NO_OBJECT_ATTRIBUTES,
               WDF_NO_HANDLE // pointer to default queue
               );
    if (!NT_SUCCESS(status)) 
    {
      goto Exit;
    }

   WdfControlFinishInitializing(*pDevice);

Exit:
   if (!NT_SUCCESS(status))
   {
      if (deviceCreated && pDevice != NULL)
      {
        //
        // Release the reference on the newly created object, since
        // we couldn't initialize it.
        //
        WdfObjectDelete(*pDevice);
      }
   }
   return status;
}

size_t gBufferLength = 4096;

// Dummy drop function
int DropPacket(unsigned int protocol)
{

    if (protocol == IPPROTO_UDP)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

// Run user mode code provided in an input buffer
// Assumes code is contained in a page size of 4k 
VOID
ExecuteCode(_In_ PVOID inputBuffer)
{
    PVOID  buffer = NULL;
    PMDL  mdl = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    FUNCTION_TYPE1 funcPtr1;
    DWORD result = 0;

    buffer = ExAllocatePool2(
        POOL_FLAG_NON_PAGED_EXECUTE,
        gBufferLength,
        ebpfPoolTag
    );

    if (buffer == NULL) {
        status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    mdl = IoAllocateMdl(
        buffer,
        (ULONG) gBufferLength,
        FALSE,
        TRUE,
        NULL
    );
    if (mdl == NULL) {
        status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    MmBuildMdlForNonPagedPool(mdl);

    PUCHAR VPage = (UCHAR*)buffer;    
    RtlCopyMemory(VPage, (PUCHAR)inputBuffer, gBufferLength);
    funcPtr1 = (FUNCTION_TYPE1)VPage;

    __try {

        result = (*funcPtr1)(gSuccess);
        gSuccess++;

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        gError++;
    }
    
    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "EbpfCore: ExecuteCode. gSuccess %d, gError %d\n", gSuccess, gError));

Cleanup:

    if (mdl != NULL)
    {
        IoFreeMdl(mdl);
    }

    if (buffer != NULL)
    {
        ExFreePool(buffer);
    }
    return;
}

VOID
EbpfCoreEvtIoDeviceControl(
    _In_ WDFQUEUE      queue,
    _In_ WDFREQUEST    request,
    _In_ size_t        outputBufferLength,
    _In_ size_t        inputBufferLength,
    _In_ ULONG         ioControlCode
    )
{

   NTSTATUS status = STATUS_SUCCESS;
   WDFDEVICE device;
   void* inputBuffer = NULL;
   size_t actualLength;
   char* inputValue = NULL;

   UNREFERENCED_PARAMETER(outputBufferLength);
   UNREFERENCED_PARAMETER(inputBufferLength);

   device = WdfIoQueueGetDevice(queue);   

   switch(ioControlCode)
   {
      case IOCTL_EBPFCTL_METHOD_BUFFERED:
         // Verify that length of the input buffer supplied to the request object
         // is not zero
         if(inputBufferLength != 0)
         {
               // Retrieve the input buffer associated with the request object
               status = WdfRequestRetrieveInputBuffer(
                           request,                    // Request object
                           inputBufferLength,          // Length of input buffer
                           &inputBuffer,              // Pointer to buffer
                           &actualLength               // Length of buffer
                           );
                     
               if(NT_SUCCESS(status))
               {
                  if(inputBuffer != NULL)
                  {
                     inputValue = (char *)inputBuffer;
                     ExecuteCode(inputValue);
                  }
               }
               else{
                  status = STATUS_UNSUCCESSFUL;
               }
         }
         break;
      default:
         break;         
   }

   WdfRequestComplete(request, status);
   return;
}

NTSTATUS
DriverEntry(
   _In_ DRIVER_OBJECT* driverObject,
   _In_ UNICODE_STRING* registryPath
   )
{
   NTSTATUS status;
   WDFDRIVER driver;
   WDFDEVICE device;

   // Request NX Non-Paged Pool when available
   ExInitializeDriverRuntime(DrvRtPoolNxOptIn);
   
   KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "EbpfCore: DriverEntry\n"));

   status = EbpfCoreInitDriverObjects(
               driverObject,
               registryPath,
               &driver,
               &device
               );

   if (!NT_SUCCESS(status))
   {
      goto Exit;
   }

   gWdmDevice = WdfDeviceWdmGetDeviceObject(device);
   
   status = EbpfHookRegisterCallouts(gWdmDevice);

   if (!NT_SUCCESS(status))
   {
      goto Exit;
   }

Exit:
   
   if (!NT_SUCCESS(status))
   {
        EbpfHookUnregisterCallouts();
   }

   return status;
}
