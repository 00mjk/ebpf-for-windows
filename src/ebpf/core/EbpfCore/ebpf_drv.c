/*++

Copyright (c) Microsoft Corporation. All rights reserved

Abstract:
WDF based driver that does the following:
1. Registers as a WFP L2 Callout
2. Opens a IOCTL surface

Environment:

    Kernel mode

--*/

#include <ntddk.h>
#include <wdf.h>

#pragma warning(push)
#pragma warning(disable:4201)       // unnamed struct/union

#include <fwpsk.h>

#pragma warning(pop)

#include <fwpmk.h>
#include <netiodef.h>
#include "ebpf_l2_hook.h"
#include "types.h"
#include "protocol.h"

// Driver global variables

DEVICE_OBJECT* gWdmDevice;
BOOLEAN gDriverUnloading = FALSE;
DRIVER_INITIALIZE DriverEntry;
EVT_WDF_DRIVER_UNLOAD EvtDriverUnload;
DWORD gError = 0;

LIST_ENTRY gUserCodeList;
KSPIN_LOCK gUserCodeLock;
UINT64 gHandle = 0;

// Typedefs 
typedef enum
{
    ebpfPoolTag = 'fpbe'
} EBPF_POOL_TAG;

typedef VOID(WINAPI* FUNCTION_TYPE) (VOID);
typedef DWORD(WINAPI* FUNCTION_TYPE1) (DWORD);
typedef DWORD(WINAPI* FUNCTION_TYPE2) (PVOID, PVOID);

//
// Constants
//
PCWSTR EbpfDeviceName = L"\\Device\\EbpfIoDevice";
PCWSTR EbpfSymbolicDeviceName = L"\\GLOBAL??\\EbpfIoDevice";

#ifndef CTL_CODE
#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)
#endif
// Device type 
#define EBPF_IOCTL_TYPE FILE_DEVICE_NETWORK

// Function codes from 0x800 to 0xFFF are for customer use.
#define IOCTL_EBPFCTL_METHOD_BUFFERED \
    CTL_CODE( EBPF_IOCTL_TYPE, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS  )

//
// Pre-Declarations
//

NTSTATUS
UnloadCode(
    _In_ uint64_t handle,
    _In_ BOOLEAN force);
VOID
EbpfCoreEvtIoDeviceControl(
    _In_ WDFQUEUE      queue,
    _In_ WDFREQUEST    request,
    _In_ size_t        outputBufferLength,
    _In_ size_t        inputBufferLength,
    _In_ ULONG         ioControlCode
    );

_Function_class_(EVT_WDF_DRIVER_UNLOAD)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
void
EvtDriverUnload(
   _In_ WDFDRIVER driverObject
   )
{
   UNREFERENCED_PARAMETER(driverObject);

   gDriverUnloading = TRUE; 

   EbpfHookUnregisterCallouts();

   UnloadCode(0, TRUE);
}

//
// Create a basic WDF driver, set up the device object
// for a callout driver and setup the ioctl surface
//
NTSTATUS
EbpfCoreInitDriverObjects(
   _Inout_ DRIVER_OBJECT* driverObject,
   _In_ const UNICODE_STRING* registryPath,
   _Out_ WDFDRIVER* pDriver,
   _Out_ WDFDEVICE* pDevice
   )
{
   NTSTATUS status;
   WDF_DRIVER_CONFIG config;
   PWDFDEVICE_INIT pInit = NULL;
   WDF_IO_QUEUE_CONFIG ioQueueConfig;   
   UNICODE_STRING ebpfDeviceName; 
   UNICODE_STRING ebpfSymDeviceName;
   BOOLEAN deviceCreated = FALSE;

   WDF_DRIVER_CONFIG_INIT(
      &config,
      WDF_NO_EVENT_CALLBACK
      );

   config.DriverInitFlags |= WdfDriverInitNonPnpDriver;
   config.EvtDriverUnload = EvtDriverUnload;

   status = WdfDriverCreate(
               driverObject,
               registryPath,
               WDF_NO_OBJECT_ATTRIBUTES,
               &config,
               pDriver
               );

   if (!NT_SUCCESS(status))
   {
      goto Exit;
   }

   DbgBreakPoint();
   pInit = WdfControlDeviceInitAllocate(
               *pDriver,               
               &SDDL_DEVOBJ_SYS_ALL_ADM_ALL // only kernel/system and admins
               );
   if (!pInit)
   {
      status = STATUS_INSUFFICIENT_RESOURCES;
      goto Exit;
   }

   WdfDeviceInitSetDeviceType(
      pInit,
      FILE_DEVICE_NETWORK
      );

   WdfDeviceInitSetCharacteristics(
      pInit,
      FILE_DEVICE_SECURE_OPEN,
      FALSE
      );

   WdfDeviceInitSetCharacteristics(
      pInit,
      FILE_AUTOGENERATED_DEVICE_NAME,
      TRUE
      );

   RtlInitUnicodeString(&ebpfDeviceName, EbpfDeviceName);
   WdfDeviceInitAssignName(
      pInit,
      &ebpfDeviceName);

   status = WdfDeviceCreate(
               &pInit,
               WDF_NO_OBJECT_ATTRIBUTES,
               pDevice
               );

   if (!NT_SUCCESS(status))
   {
      // do not free if any other call 
      // after WdfDeviceCreate fails.
      WdfDeviceInitFree(pInit);
      pInit = NULL;
      goto Exit;
   }

   deviceCreated = TRUE;

   // create symbolic link for control object for um
   RtlInitUnicodeString(&ebpfSymDeviceName, EbpfSymbolicDeviceName);
   status = WdfDeviceCreateSymbolicLink(
               *pDevice,
               &ebpfSymDeviceName);

   if (!NT_SUCCESS(status))
   {
      goto Exit;
   }

   // parallel default queue
   WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&ioQueueConfig,
      WdfIoQueueDispatchParallel);

   ioQueueConfig.EvtIoDeviceControl = EbpfCoreEvtIoDeviceControl;

   status = WdfIoQueueCreate(
               *pDevice,
               &ioQueueConfig,
               WDF_NO_OBJECT_ATTRIBUTES,
               WDF_NO_HANDLE // pointer to default queue
               );
    if (!NT_SUCCESS(status)) 
    {
      goto Exit;
    }

   WdfControlFinishInitializing(*pDevice);

   KeInitializeSpinLock(&gUserCodeLock);
   InitializeListHead(&gUserCodeList);

Exit:
   if (!NT_SUCCESS(status))
   {
      if (deviceCreated && pDevice != NULL)
      {
        //
        // Release the reference on the newly created object, since
        // we couldn't initialize it.
        //
        WdfObjectDelete(*pDevice);
      }
   }
   return status;
}

size_t gBufferLength = 4096;

// Dummy drop function
int DropPacket(unsigned int protocol)
{

    if (protocol == IPPROTO_UDP)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

NTSTATUS
CheckAndAttachCodeToHook(
    _In_ struct EbpfOpAttachDetachRequest* attachRequest
)
{
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL irql;
    UserCode* code = NULL;

    KeAcquireSpinLock(&gUserCodeLock, &irql);
    LIST_ENTRY* listEntry = gUserCodeList.Flink;
    while (listEntry != &gUserCodeList)
    {
        code = CONTAINING_RECORD(listEntry, UserCode, entry);
        if (attachRequest->handle == code->handle)
        {
            code->attached = TRUE;
            break;
        }

        listEntry = listEntry->Flink;
    }
    KeReleaseSpinLock(&gUserCodeLock, irql);

    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "EbpfCore: AttachCodeToHook 0x%lx handle \n", attachRequest->handle));

    return status;
}

NTSTATUS
DetachCodeFromHook(
    _In_ struct EbpfOpAttachDetachRequest* detachRequest
)
{
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL irql;
    UserCode* code = NULL;

    KeAcquireSpinLock(&gUserCodeLock, &irql);
    LIST_ENTRY* listEntry = gUserCodeList.Flink;
    while (listEntry != &gUserCodeList)
    {
        code = CONTAINING_RECORD(listEntry, UserCode, entry);
        if (detachRequest->handle == code->handle)
        {
            code->attached = FALSE;
            break;
        }

        listEntry = listEntry->Flink;
    }
    KeReleaseSpinLock(&gUserCodeLock, irql);

    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "EbpfCore: DetachCodeFromHook 0x%lx handle \n", detachRequest->handle));

    return status;
}


NTSTATUS
UnloadCode(
    _In_ uint64_t handle,
    _In_ BOOLEAN force)
{
    NTSTATUS status = STATUS_SUCCESS;
    KIRQL irql;
    UserCode* code = NULL;
    BOOLEAN found = FALSE;

    KeAcquireSpinLock(&gUserCodeLock, &irql);
    LIST_ENTRY* listEntry = gUserCodeList.Flink;
    while (listEntry->Flink != &gUserCodeList)
    {
        code = CONTAINING_RECORD(listEntry, UserCode, entry);
        listEntry = listEntry->Flink;
        if (force || handle == code->handle)
        {
            found = TRUE;

            KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "EbpfCore: UnloadCode: 0x%lx handle: 0x%lx. \n", code, code->handle));
            RemoveEntryList(&code->entry);
            if (code != NULL)
            {
                ExFreePool(code);
            }

            if (!force)
            {
                break;
            }
        }
    }
    KeReleaseSpinLock(&gUserCodeLock, irql);
    if (!force && !found)
    {
        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "EbpfCore: UnloadCode: failed to find handle 0x%lx \n",handle));
    }
    return status;
}

NTSTATUS
AllocateAndLoadCode(
    _In_ struct EbpfOpLoadRequest* inputRequest,
    _Out_ struct EbpfOpLoadReply* loadReply)
{
    NTSTATUS status = STATUS_SUCCESS;
    PVOID  buffer = NULL;
    UINT16 codeSize = 0;
    KIRQL irql;
    UserCode* code = NULL;

    // validate
    if (inputRequest->header.length > gBufferLength)
    {
        status = STATUS_INVALID_PARAMETER;
        goto Done;
    }

    if (loadReply == NULL)
    {
        status = STATUS_INVALID_PARAMETER;
        goto Done;
    }

    // allocate
    codeSize = inputRequest->header.length;
    buffer = ExAllocatePool2(
        POOL_FLAG_NON_PAGED_EXECUTE,
        codeSize + sizeof(UserCode),
        ebpfPoolTag
    );
    if (buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Done;
    }

    // copy and hang on to user code
    code = buffer;   
    buffer = (byte*)buffer + sizeof(UserCode);
    RtlCopyMemory(buffer, (PUCHAR)inputRequest->machine_code, codeSize);
    code->code = buffer;

    // todo: polish handle allocation logic
    code->handle = (0xffff | gHandle++);

    KeAcquireSpinLock(&gUserCodeLock, &irql);
    InsertTailList(&gUserCodeList, &code->entry);
    KeReleaseSpinLock(&gUserCodeLock, irql);

    // construct the response
    loadReply->handle = code->handle;
    loadReply->header.id = load_code;
    loadReply->header.length = sizeof(struct EbpfOpLoadReply);
    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "EbpfCore: AllocateAndLoadCode code: 0x%lx handle: 0x%lx. \n", code, code->handle));

Done:
    if (!NT_SUCCESS(status))
    {
        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "EbpfCore: AllocateAndLoadCode code failed %d\n", status));
    }
    return status;
}

// Returns xdp_action
// permit = 1
// drop = 2
UINT32
ExecuteCodeAtHook(
    _In_ void* buffer
)
{
    KIRQL irql;
    UserCode* code = NULL;
    XDP_HOOK funcPtr;
    DWORD result = permit;
    BOOLEAN found = FALSE;

    xdp_md ctx = {0};
    ctx.data = (UINT64) buffer;
    ctx.data_end = (UINT64) ((char *) buffer + sizeof(IPV4_HEADER) + sizeof(UDP_HEADER));

    KeAcquireSpinLock(&gUserCodeLock, &irql);

    LIST_ENTRY* listEntry = gUserCodeList.Flink;
    while (listEntry != &gUserCodeList)
    {
        code = CONTAINING_RECORD(listEntry, UserCode, entry);
        if (code->attached)
        {
            // find the first one and run.
            found = TRUE;
            break;
        }

        listEntry = listEntry->Flink;
    }

    if (found)
    {
        funcPtr = (XDP_HOOK)code->code;
        __try {
            result = (*funcPtr)(&ctx);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            gError++;
        }
    }

    KeReleaseSpinLock(&gUserCodeLock, irql);

    KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "EbpfCore: ExecuteCode. gError %d\n", gError));

    return (UINT32)result;
}

VOID
EbpfCoreEvtIoDeviceControl(
    _In_ WDFQUEUE      queue,
    _In_ WDFREQUEST    request,
    _In_ size_t        outputBufferLength,
    _In_ size_t        inputBufferLength,
    _In_ ULONG         ioControlCode
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    WDFDEVICE device;
    void* inputBuffer = NULL;
    void* outputBuffer = NULL;
    size_t actualInputLength;
    size_t actualOutputLength;
    struct EbpfOpHeader* inputRequest = NULL;

    UNREFERENCED_PARAMETER(outputBufferLength);
    UNREFERENCED_PARAMETER(inputBufferLength);

    device = WdfIoQueueGetDevice(queue);

    switch (ioControlCode)
    {
    case IOCTL_EBPFCTL_METHOD_BUFFERED:
        // Verify that length of the input buffer supplied to the request object
        // is not zero
        if (inputBufferLength != 0)
        {
            // Retrieve the input buffer associated with the request object
            status = WdfRequestRetrieveInputBuffer(
                request,                   // Request object
                inputBufferLength,         // Length of input buffer
                &inputBuffer,              // Pointer to buffer
                &actualInputLength         // Length of buffer
            );

            if (!NT_SUCCESS(status))
            {
                KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "EbpfCore: Input buffer failure %d\n", status));
                goto Done;
            }

            if (inputBuffer == NULL)
            {
                status = STATUS_INVALID_PARAMETER;
                goto Done;
            }

            if (inputBuffer != NULL)
            {

                status = EbpfHookRegisterCallouts(gWdmDevice);
                // non fatal for now while testing               

                inputRequest = inputBuffer;
                switch (inputRequest->id)
                {
                case load_code:
                {
                    // Retrieve output buffer associated with the request object
                    status = WdfRequestRetrieveOutputBuffer(
                        request,
                        outputBufferLength,
                        &outputBuffer,
                        &actualOutputLength
                    );
                    if (!NT_SUCCESS(status))
                    {
                        KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "EbpfCore: Output buffer failure %d\n", status));
                        goto Done;
                    }
                    if (outputBuffer == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                        goto Done;
                    }
                    status = AllocateAndLoadCode(
                        (struct EbpfOpLoadRequest*)inputRequest,
                        outputBuffer);
                    break;
                }
                case unload_code:
                {
                    struct EbpfOpUnloadRequest* unloadRequest;
                    unloadRequest = inputBuffer;
                    status = UnloadCode(unloadRequest->handle, FALSE);
                    break;
                }
                case attach:
                {
                    status = CheckAndAttachCodeToHook(inputBuffer);
                    break;
                }
                case detach:
                    break;
                default:
                    break;
                }
            }
        }
        break;
    default:
        break;
    }

Done:
    WdfRequestCompleteWithInformation(request, status, outputBufferLength);
    return;
}

NTSTATUS
DriverEntry(
   _In_ DRIVER_OBJECT* driverObject,
   _In_ UNICODE_STRING* registryPath
   )
{
   NTSTATUS status;
   WDFDRIVER driver;
   WDFDEVICE device;

   // Request NX Non-Paged Pool when available
   ExInitializeDriverRuntime(DrvRtPoolNxOptIn);
   
   KdPrintEx((DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL, "EbpfCore: DriverEntry\n"));

   status = EbpfCoreInitDriverObjects(
               driverObject,
               registryPath,
               &driver,
               &device
               );

   if (!NT_SUCCESS(status))
   {
      goto Exit;
   }

   gWdmDevice = WdfDeviceWdmGetDeviceObject(device);
   
   EbpfHookRegisterCallouts(gWdmDevice);
   // ignore status. at boot, registration can fail.
   // we will try to re-register during prog load.

Exit:
   
   if (!NT_SUCCESS(status))
   {
        EbpfHookUnregisterCallouts();
   }

   return status;
}
